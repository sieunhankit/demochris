<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Admin - Live Streams</title>
    <style>
      body {
        font-family: system-ui;
        margin: 20px;
        background: #0b0b0b;
        color: #fff;
      }
      input,
      button {
        padding: 10px;
        border-radius: 10px;
        border: 1px solid #333;
        background: #111;
        color: #fff;
      }
      .row {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
        align-items: center;
      }
      .muted {
        opacity: 0.7;
      }
      .grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
        gap: 12px;
        margin-top: 14px;
      }
      .card {
        border: 1px solid #222;
        border-radius: 14px;
        padding: 12px;
        background: #111;
      }
      video {
        width: 100%;
        max-height: 320px;
        background: #000;
        border-radius: 12px;
      }
      .badge {
        display: inline-block;
        padding: 4px 8px;
        border-radius: 999px;
        border: 1px solid #333;
        background: #0f0f0f;
        font-size: 12px;
        opacity: 0.85;
      }
    </style>
  </head>
  <body>
    <h2>Admin - Live Streams</h2>

    <div class="row">
      <input id="room" placeholder="room id" value="default" />
      <button id="btn">Connect</button>
    </div>
    <div id="status" class="muted" style="margin-top: 8px"></div>

    <div class="grid" id="grid"></div>

    <script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>
    <script>
      const AUTO_DOWNLOAD_ON_DISCONNECT = true; // đổi false nếu chỉ muốn hiện nút Download

      function stopRecAndFinalize(participantId, reason = "disconnected") {
        const r = recordings.get(participantId);
        if (!r?.recorder) return;

        const st = document.getElementById(`recst-${participantId}`);
        if (st) st.textContent = `Finalizing… (${reason})`;

        try {
          // cố lấy chunk cuối (nếu browser hỗ trợ)
          if (r.recorder.state === "recording" && r.recorder.requestData) {
            r.recorder.requestData();
          }
        } catch {}

        try {
          if (r.recorder.state === "recording") r.recorder.stop();
        } catch {}
      }

      // gọi sau khi recorder.onstop đã tạo blobUrl
      function autoDownloadIfNeeded(participantId) {
        if (!AUTO_DOWNLOAD_ON_DISCONNECT) return;
        const r = recordings.get(participantId);
        if (!r?.blobUrl) return;
        downloadRecord(participantId);
      }

      // bind auto stop theo trạng thái WebRTC
      function bindPeerAutoFinalize(participantId, pc) {
        const doFinalize = (why) => stopRecAndFinalize(participantId, why);

        pc.onconnectionstatechange = () => {
          const s = pc.connectionState;
          if (s === "disconnected" || s === "failed" || s === "closed")
            doFinalize(s);
        };

        pc.oniceconnectionstatechange = () => {
          const s = pc.iceConnectionState;
          if (s === "disconnected" || s === "failed" || s === "closed")
            doFinalize(s);
        };
      }
      const socket = io(location.origin, { transports: ["websocket"] });
      const $ = (id) => document.getElementById(id);
      const status = (t) => ($("status").textContent = t);

      let roomId = "";
      // participantSocketId -> { pc, videoEl }
      const peers = new Map();
      const recordings = new Map();
      const iceServers = [
        { urls: "stun:stun.l.google.com:19302" },
        { urls: "stun:stun1.l.google.com:19302" },
      ];

      $("btn").onclick = () => {
        roomId = $("room").value.trim();
        socket.emit("admin:subscribe", { roomId });
        status("Connected. Waiting for streams…");
      };

      socket.on("room:update", (participants) => {
        // Show only those who enabled streaming (server already filters)
        renderCards(participants);
        status(`Streaming enabled users: ${participants.length}`);
      });

      socket.on("participant:streamAllowed", ({ socketId, allow }) => {
        // If user turned off, cleanup their peer
        if (!allow) cleanupPeer(socketId);
      });

      // WebRTC offer from participant (they auto-start)
      socket.on("webrtc:offer", async ({ from, sdp }) => {
        await ensurePeer(from);
        const peer = peers.get(from);

        await peer.pc.setRemoteDescription(new RTCSessionDescription(sdp));
        const answer = await peer.pc.createAnswer();
        await peer.pc.setLocalDescription(answer);

        socket.emit("webrtc:answer", {
          to: from,
          sdp: peer.pc.localDescription,
        });
      });

      socket.on("webrtc:ice", async ({ from, candidate }) => {
        const peer = peers.get(from);
        if (!peer) return;
        try {
          await peer.pc.addIceCandidate(candidate);
        } catch {}
      });

      async function ensurePeer(participantId) {
        if (peers.has(participantId)) return;

        const pc = new RTCPeerConnection({ iceServers });
        pc.onicecandidate = (e) => {
          if (e.candidate)
            socket.emit("webrtc:ice", {
              to: participantId,
              candidate: e.candidate,
            });
        };

        // ✅ bind auto finalize khi peer rớt
        bindPeerAutoFinalize(participantId, pc);

        const videoEl = createVideoCard(participantId);

        pc.ontrack = (e) => {
          const stream = e.streams[0];
          videoEl.srcObject = stream;
          videoEl.muted = true;
          videoEl.play?.().catch(() => {});

          // ✅ nếu track end (user đóng tab/mất mạng) -> finalize
          const [vtrack] = stream.getVideoTracks();
          if (vtrack) {
            vtrack.onended = () =>
              stopRecAndFinalize(participantId, "track ended");
          }
        };

        peers.set(participantId, { pc, videoEl });
      }

      function createVideoCard(participantId) {
        const grid = $("grid");
        const card = document.createElement("div");
        card.className = "card";
        card.id = `card-${participantId}`;

        card.innerHTML = `
  <div class="row" style="justify-content:space-between; align-items:flex-start;">
    <div style="min-width:0;">
      <div><b>Participant</b> <span class="badge">${participantId}</span></div>
      <div class="muted" style="margin-top:4px;">Auto stream (user opted-in)</div>
      <div id="recst-${participantId}" class="muted" style="margin-top:6px;">Idle</div>
    </div>

    <div class="row" style="gap:8px; justify-content:flex-end;">
      <button style="padding:8px 10px;border-radius:10px;"
        onclick="window._rec('${participantId}')">Record</button>

      <button style="padding:8px 10px;border-radius:10px;"
        onclick="window._stoprec('${participantId}')">Stop Rec</button>

      <button id="dl-${participantId}" style="display:none; padding:8px 10px;border-radius:10px;"
        onclick="window._dl('${participantId}')">Download</button>

      <button style="padding:8px 10px;border-radius:10px;"
        onclick="window._stop('${participantId}')">Stop Stream</button>
    </div>
  </div>

  <div style="margin-top:10px;">
    <video playsinline autoplay></video>
  </div>
`;

        grid.appendChild(card);
        return card.querySelector("video");
      }

      window._stop = (participantId) => cleanupPeer(participantId);

      function cleanupPeer(participantId) {
        stopRecAndFinalize(participantId, "cleanup");
        const peer = peers.get(participantId);
        if (!peer) return;

        try {
          peer.pc.close();
        } catch {}
        peers.delete(participantId);

        const card = document.getElementById(`card-${participantId}`);
        const r = recordings.get(participantId);
        if (r?.recorder && r.recorder.state === "recording") {
          try {
            r.recorder.stop();
          } catch {}
        }
        if (r?.blobUrl) URL.revokeObjectURL(r.blobUrl);
        recordings.delete(participantId);
        if (card) card.remove();
      }

      function renderCards(participants) {
        // Keep existing cards; remove those no longer in list
        const allowedSet = new Set(participants.map((p) => p.socketId));
        for (const id of [...peers.keys()]) {
          if (!allowedSet.has(id)) cleanupPeer(id);
        }
        // (Cards will be created when offer arrives)
      }
      function pickMime() {
        const cands = [
          "video/webm;codecs=vp9",
          "video/webm;codecs=vp9,opus",
          "video/webm;codecs=vp8",
          "video/webm;codecs=vp8,opus",
          "video/webm",
        ];
        for (const t of cands) {
          if (window.MediaRecorder && MediaRecorder.isTypeSupported(t))
            return t;
        }
        return "";
      }

      function startRecord(participantId) {
        const peer = peers.get(participantId);
        const videoEl = peer?.videoEl;
        const stream = videoEl?.srcObject;

        if (!stream) {
          alert("Chưa nhận được stream. Đợi video chạy rồi bấm Record lại.");
          return;
        }

        const prev = recordings.get(participantId);
        if (prev?.recorder && prev.recorder.state === "recording") return;
        if (prev?.blobUrl) URL.revokeObjectURL(prev.blobUrl);

        const chunks = [];
        const mimeType = pickMime();

        // ✅ Bitrate cao hơn -> nét hơn (tuỳ máy: 6-12 Mbps)
        const recorderOptions = {
          mimeType: mimeType || undefined,
          videoBitsPerSecond: 10_000_000, // 10 Mbps
          // audioBitsPerSecond: 128_000, // nếu có audio thì bật
        };

        const recorder = new MediaRecorder(
          stream,
          mimeType ? recorderOptions : undefined
        );

        recorder.ondataavailable = (e) => {
          if (e.data && e.data.size > 0) chunks.push(e.data);
        };

        recorder.onstop = () => {
          const blob = new Blob(chunks, { type: mimeType || "video/webm" });
          const blobUrl = URL.createObjectURL(blob);

          recordings.set(participantId, { recorder, chunks, blobUrl, blob });

          const dl = document.getElementById(`dl-${participantId}`);
          if (dl) dl.style.display = "inline-flex";

          const st = document.getElementById(`recst-${participantId}`);
          if (st)
            st.textContent = `Recorded: ${(blob.size / 1024 / 1024).toFixed(
              2
            )} MB`;
            autoDownloadIfNeeded(participantId);
        };

        recordings.set(participantId, {
          recorder,
          chunks,
          blobUrl: null,
          blob: null,
        });

        recorder.start(1000);
        const st = document.getElementById(`recst-${participantId}`);
        if (st) st.textContent = "● Recording (HQ)…";
      }

      function stopRecord(participantId) {
        const r = recordings.get(participantId);
        if (!r?.recorder) return;
        if (r.recorder.state === "recording") r.recorder.stop();
      }

      function downloadRecord(participantId) {
        const r = recordings.get(participantId);
        if (!r?.blobUrl) return;

        const a = document.createElement("a");
        a.href = r.blobUrl;

        const ts = new Date().toISOString().replace(/[:.]/g, "-");
        a.download = `recording-${participantId}-${ts}.webm`;

        document.body.appendChild(a);
        a.click();
        a.remove();
      }

      // expose for inline onclick
      window._rec = (id) => startRecord(id);
      window._stoprec = (id) => stopRecord(id);
      window._dl = (id) => downloadRecord(id);
    </script>
  </body>
</html>
